<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker</title>
      <link href="/2022/04/07/docker/"/>
      <url>/2022/04/07/docker/</url>
      
        <content type="html"><![CDATA[<p>日期：2021/3/4</p><p>内容出处：黑马：<a href="https://www.bilibili.com/video/BV1CJ411T7BK?p=1">https://www.bilibili.com/video/BV1CJ411T7BK?p=1</a></p><p>所学内容：docker安装、docker命令、Docker容器的数据、Dockerfile自定义镜像、Docker-Compose、Docker镜像仓库</p><p>遇到的问题：</p><p>总结：</p><p>今天学习了docker，了解了它的概念，完成了docker的安装，学习了docker的一些相关命令并完成了docker镜像和容器的增删查导入导出，后面又学习了docker 的数据卷和应用部署，并通过部外部机器访问了部署的项目。后续又搭建私有仓库，从公共仓库拉取镜像传到私有仓库，反之也可（跟maven私有仓库操作差不多）。</p><h1 id="一、docker安装"><a href="#一、docker安装" class="headerlink" title="一、docker安装"></a>一、docker安装</h1><p>安装命令，在CentOS 7 系统下安装（<a href="https://blog.csdn.net/promsing/article/details/120208826?ops_request_misc=%7B%22request_id%22:%22164767546916782184657122%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164767546916782184657122&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-120208826.142%5Ev2%5Epc_search_result_control_group,143%5Ev4%5Econtrol&utm_term=centos7%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">centos7安装教程</a>），需要能联网</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1、yum 包更新到最新 </span><br><span class="line">yum update</span><br><span class="line"># 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 </span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"># 3、 设置yum源</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"># 4、 安装docker，出现输入的界面都按 y </span><br><span class="line">yum install -y docker-ce</span><br><span class="line"># 5、 查看docker版本，验证是否验证成功</span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>设置容器镜像服务，找到<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云镜像加速器</a>里的命令，直接复制到centos 7 终端即可</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1646286993058-4da0ff1f-8b08-467a-b1d1-950fb8cfe515.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1646287122456-0989a9d3-bb21-4b94-b3d0-e0fcbc6ffaed.png" alt="img"></p><p>可用cat /etc/docker/daemon.json  查看该文件下是否有添加该镜像加速器</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1646287301311-6481e291-e7d6-4bae-b370-563bb16bbad9.png" alt="img"></p><h1 id="二、docker命令"><a href="#二、docker命令" class="headerlink" title="二、docker命令"></a>二、docker命令</h1><h2 id="1-进程相关命令"><a href="#1-进程相关命令" class="headerlink" title="1. 进程相关命令"></a>1. 进程相关命令</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1646286880998-742a0a28-28a4-4c29-bfe1-5d5e8d00ffc8.png" alt="img"></p><h2 id="2-镜像相关命令"><a href="#2-镜像相关命令" class="headerlink" title="2. 镜像相关命令"></a>2. 镜像相关命令</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1646289098196-01a57c58-dbc2-4b03-956c-ea4d2965e7d9.png" alt="img"></p><ul><li>使用docker save导出镜像到磁盘 </li></ul><p>docker save -o [保存的目标文件名称] [镜像名称]</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647913024896-a6a9454a-75e0-4fd3-9d3f-2ffa0beebbb5.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647913066026-500355c1-c764-4922-8edb-92d0a43c5236.png" alt="img"></p><p>使用docker load加载镜像</p><p>先删除本地的镜像：</p><p>docker rmi redis:7.0-rc2</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647913375063-252ae4c2-e8ed-493a-b2cd-57f08c6a9e44.png" alt="img"></p><p>然后运行命令，加载本地文件：</p><p>docker load -i redis.tar</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647913443677-cf48c301-9488-40aa-b6ff-3ff4ae4f04e4.png" alt="img"></p><p>例：去docker hub 搜索redis可用的镜像版本<a href="https://hub.docker.com/">https://hub.docker.com</a></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1646289267365-30becb2b-804d-4625-ae84-fc79da96b7e7.png" alt="img"></p><p>如下为redis支持的tags版本</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1646289398315-ac8d83e5-0452-4ef6-b46e-a5abb52f1bee.png" alt="img"></p><h2 id="3-容器相关命令"><a href="#3-容器相关命令" class="headerlink" title="3.  容器相关命令"></a>3.  容器相关命令</h2><p>容器操作的命令如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647914033616-5d17c88e-ed5b-4746-97e9-5b04f84de90d.png" alt="img"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p> <img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1646289675236-ae295a69-93fe-4b48-90ae-22fd3b018ccc.png" alt="img"></p><p>例子：</p><p>创建并启动容器：docker run -id –name=m1 mysql /bin/bash</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1646294018805-361463a6-d7a0-45ac-848a-952b76cce5a5.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1646289975773-8ed83495-6f54-41fd-9c1f-c1a157f1693d.png" alt="img"></p><ul><li><p>docker rm 容器名称 -f ： 强制删除运行中的</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li></ul><h3 id="案例1-创建并运行一个容器"><a href="#案例1-创建并运行一个容器" class="headerlink" title="案例1-创建并运行一个容器"></a>案例1-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name ng -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647914074691-6feaec22-c168-454f-bbc0-f991238fde8a.png" alt="img"></p><h3 id="案例2-进入容器，修改文件"><a href="#案例2-进入容器，修改文件" class="headerlink" title="案例2-进入容器，修改文件"></a>案例2-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it ng bash</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li> docker exec ：进入容器内部，执行一个命令 </li><li> -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 </li><li> ng ：要进入的容器的名称 (自己命名的)</li><li> bash：进入容器后执行的命令，bash是一个linux终端交互命令 </li></ul><p>2）进入nginx的HTML所在目录 /usr/share/nginx/html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647915695755-1dbe5d65-be00-4ca8-b019-c8c3b1419604.png" alt="img"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647916343750-ee80136a-0e59-4a53-8fcf-d7a422a33798.png" alt="img"></p><p>我们执行命令，进入该目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/share/nginx/html</span><br></pre></td></tr></table></figure><p>查看目录下文件：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647915897023-2efbaa77-e4a2-49ab-a357-ad2e7592e996.png" alt="img"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27; index.html</span><br><span class="line">sed -i &#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27; index.html</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647916803745-96a59a45-fa28-4006-90dc-b83273684956.png" alt="img"></p><p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.129，即可看到结果：">http://192.168.150.129，即可看到结果：</a></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647916834800-8997b623-fe28-4650-95e7-9c82614664d6.png" alt="img"></p><h3 id="练习一："><a href="#练习一：" class="headerlink" title="练习一："></a>练习一：</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647917897353-3264a6e2-ab48-41dc-bf79-d3d852c94cc9.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647917758147-482376fe-ccec-4c49-8b38-e14e0e780077.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647917721053-ae47ac02-091f-4a2b-bbcf-fa3bd6848316.png" alt="img"></p><h3 id="练习二："><a href="#练习二：" class="headerlink" title="练习二："></a>练习二：</h3><p>进入redis容器，并执行redis-cli客户端命令，存入num=666</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647918297239-0049bbcc-f30e-4512-9dcb-e129be2435bb.png" alt="img"></p><h1 id="三、Docker容器的数据"><a href="#三、Docker容器的数据" class="headerlink" title="三、Docker容器的数据"></a>三、Docker容器的数据</h1><h2 id="一、数据卷概念及作用"><a href="#一、数据卷概念及作用" class="headerlink" title="一、数据卷概念及作用"></a>一、数据卷概念及作用</h2><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p> <img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647918571513-a818bd32-448d-468b-a805-7acaeb47578e.png" alt="img"></p><p> 一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p><p><strong>数据卷作用</strong> </p><p>• 容器数据持久化 </p><p>• 外部机器和容器间接通信 </p><p>• 容器之间数据交换  </p><h2 id="二、数据卷操作命令"><a href="#二、数据卷操作命令" class="headerlink" title="二、数据卷操作命令"></a>二、数据卷操作命令</h2><h3 id="1-数据卷基本语法"><a href="#1-数据卷基本语法" class="headerlink" title="1.数据卷基本语法"></a>1.数据卷基本语法</h3><p>数据卷操作的基本语法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><p>create  创建一个volume</p><p>inspect  显示一个或多个volume的信息</p><p>ls  列出所有的volume</p><p> prune  删除未使用的volume</p><p> rm  删除一个或多个指定的volume</p><h3 id="2-创建和查看数据卷"><a href="#2-创建和查看数据卷" class="headerlink" title="2.创建和查看数据卷"></a>2.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure><p>② 查看所有数据</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647919365788-59a1f7a9-2f5c-4e45-972a-d7804f5a78bc.png" alt="img"></p><p>③ 查看数据卷详细信息卷</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647919314999-e0990b84-dd54-411f-a03b-a63fb902946d.png" alt="img"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><h3 id="3-挂载数据卷"><a href="#3-挂载数据卷" class="headerlink" title="3.挂载数据卷"></a>3.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li></ul><p>小结：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647932493924-1730bc87-e6a0-4086-9cd8-bc0577210311.png" alt="img"></p><h3 id="案例-给nginx挂载数据卷"><a href="#案例-给nginx挂载数据卷" class="headerlink" title="案例-给nginx挂载数据卷"></a>案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的HTML目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name ng -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>② 进入html数据卷所在位置，并修改HTML内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入该目录</span></span><br><span class="line">cd /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647933318432-964c6ac0-fafe-452d-a3ea-0ebd750ba497.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647933418631-7485e2dd-961d-4757-b7f2-8340f366abfd.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647933395000-8de24bb4-3cd0-4742-8d23-2ba8c6c191e3.png" alt="img"></p><p>访问<a href="http://192.168.150.129/">http://192.168.150.129/</a></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647931850788-33dff642-da56-4878-abaf-da68b35b874c.png" alt="img"></p><h3 id="案例-给MySQL挂载本地目录"><a href="#案例-给MySQL挂载本地目录" class="headerlink" title="案例-给MySQL挂载本地目录"></a>案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li></ul><p>如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647919722062-3a79902c-79d1-4a2c-94fd-8546d9a57f75.png" alt="img"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>2）创建目录/tmp/mysql/data</p><p>3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf</p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载/tmp/mysql/data到mysql容器内数据存储目录</p><p>② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><p>1）在将课前资料中的<a href="https://pan.baidu.com/s/13XwuHsoOKN6DMylmx8yq8Q?pwd=xkk6">mysql.tar</a>（提取码xkk6）文件上传到虚拟机，通过load命令加载为镜像</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647949901355-de7c4cfa-ae08-449b-bdf4-afc3c2903814.png" alt="img"></p><p>2）创建目录/tmp/mysql/data</p><p>3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647949824622-d2b551ef-3a95-4291-a550-bdd4cf474c7b.png" alt="img"></p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载/tmp/mysql/data到mysql容器内数据存储目录</p><p>② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><p>docker run \</p><p>​    –name mysql \</p><p>​    -e MYSQL_ROOT_PASSWORD=123 \</p><p>​    -p 3306:3306 \</p><p>​    -v  /tmp/mysql/conf /hmy.cnf:/etc/mysql/my.cnf and /etc/mysql/conf.d/hmy.cnf \</p><p>​    -v  /tmp/mysql/data:/var/lib/mysql \</p><p>​    -d mysql:5.7.25</p><p>小结：</p><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h1 id="四、Dockerfile自定义镜像"><a href="#四、Dockerfile自定义镜像" class="headerlink" title="四、Dockerfile自定义镜像"></a>四、Dockerfile自定义镜像</h1><p> 常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="1-镜像结构"><a href="#1-镜像结构" class="headerlink" title="1.镜像结构"></a>1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1647932714441-0d3231ec-b866-4f9e-86f2-cdb8de21bf30.png" alt="img"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="2-Dockerfile语法"><a href="#2-Dockerfile语法" class="headerlink" title="2.Dockerfile语法"></a>2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118761850-55b107ef-3554-4e87-aa75-52512ed6f8c7.png" alt="img"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="3-构建Java项目"><a href="#3-构建Java项目" class="headerlink" title="3.构建Java项目"></a>3.构建Java项目</h2><h3 id="（1）基于Ubuntu构建Java项目"><a href="#（1）基于Ubuntu构建Java项目" class="headerlink" title="（1）基于Ubuntu构建Java项目"></a>（1）基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li> 步骤1：新建一个空文件夹docker-demo</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118791070-d7706a51-f2a6-4512-bcc8-885a7739231f.png" alt="img"></p><ul><li>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118805564-e8eaa28d-a617-4f74-8617-8405ba731b16.png" alt="img"></li><li>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录<br><img src="D:\blog\Hexo\source_posts\assets\image-20210801101410200.png" alt="img"><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118840554-e9dd01c8-3ea8-4fcc-881a-45a75ed19942.png" alt="img"></li><li>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118858886-623e791b-1094-48c5-bd12-699b583e413b.png" alt="img">其中的内容如下： </li></ul><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="bash"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure><ul><li>步骤5：进入docker-demo<br>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下 </li><li> 步骤6：运行命令： </li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure><p>最后访问 <a href="http://192.168.150.101:8090/hello/count%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84ip%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p><h3 id="（2）基于java8构建Java项目"><a href="#（2）基于java8构建Java项目" class="headerlink" title="（2）基于java8构建Java项目"></a>（2）基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p> ① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile </p></li><li><p> ② 拷贝课前资料提供的docker-demo.jar到这个目录中 </p></li><li><p> ③ 编写Dockerfile文件： </p></li><li><ul><li> a ）基于java:8-alpine作为基础镜像 </li><li> b ）将app.jar拷贝到镜像中 </li><li> c ）暴露端口 </li><li>d ）编写入口ENTRYPOINT<br>内容如下： </li></ul></li></ul><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure><ul><li> ④ 使用docker build命令构建镜像 </li><li> ⑤ 使用docker run创建容器并运行 </li></ul><p>小结：</p><ol><li> Dockerfile的本质是一个文件，通过指令描述镜像的构建过程 </li><li> Dockerfile的第一行必须是FROM，从一个基础镜像来构建 </li><li> 基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine </li></ol><h1 id="五、Docker-Compose"><a href="#五、Docker-Compose" class="headerlink" title="五、Docker-Compose"></a>五、Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118879185-34b7b573-f676-4f18-936e-dced161b2f6c.png" alt="img"></p><h2 id="1-初识DockerCompose"><a href="#1-初识DockerCompose" class="headerlink" title="1.初识DockerCompose"></a>1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&quot;3.8&quot;</span></span><br><span class="line"> services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:<span class="number">5.7</span><span class="number">.25</span></span><br><span class="line">    environment:</span><br><span class="line">     MYSQL_ROOT_PASSWORD: <span class="number">123</span> </span><br><span class="line">    volumes:</span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">&quot;8090:8090&quot;</span></span><br></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="2-安装DockerCompose"><a href="#2-安装DockerCompose" class="headerlink" title="2.安装DockerCompose"></a>2.安装DockerCompose</h2><h3 id="（1）下载"><a href="#（1）下载" class="headerlink" title="（1）下载"></a>（1）下载</h3><p>Linux下需要通过命令下载：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648119168918-b7d77bf4-9a6f-4b34-bb9d-3ef4d702f444.png" alt="img"></p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h3 id="（2）修改文件权限"><a href="#（2）修改文件权限" class="headerlink" title="（2）修改文件权限"></a>（2）修改文件权限</h3><p>修改文件权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改权限</span></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="（3）Base自动补全命令："><a href="#（3）Base自动补全命令：" class="headerlink" title="（3）Base自动补全命令："></a>（3）Base自动补全命令：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 补全命令</span></span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h2 id="3-部署微服务集群"><a href="#3-部署微服务集群" class="headerlink" title="3.部署微服务集群"></a>3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="（1）compose文件"><a href="#（1）compose文件" class="headerlink" title="（1）compose文件"></a>（1）compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118907422-8426d925-44e9-4131-ba50-d070f112c200.png" alt="img"></p><p>内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MODE:</span> <span class="string">standalone</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.25</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span></span><br><span class="line">  <span class="attr">userservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./user-service</span></span><br><span class="line">  <span class="attr">orderservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./order-service</span></span><br><span class="line">  <span class="attr">gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./gateway</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10010:10010&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，其中包含5个service服务：</p><ul><li><p><code>nacos</code>：作为注册中心和配置中心 </p></li><li><ul><li><code>image: nacos/nacos-server</code>： 基于nacos/nacos-server镜像构建</li><li><code>environment</code>：环境变量 </li></ul></li><li><ul><li><ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li></ul></li><li><ul><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><p><code>mysql</code>：数据库 </p></li><li><ul><li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li><li><code>environment</code>：环境变量 </li></ul></li><li><ul><li><ul><li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li></ul></li></ul></li><li><ul><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><p><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</p></li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118920588-5fd651d0-abad-46ce-91ec-a76cdacd9877.png" alt="img"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118925899-a053c9e1-1cfb-43ca-8562-742b9235f147.png" alt="img"></p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure><h3 id="（2）修改微服务配置"><a href="#（2）修改微服务配置" class="headerlink" title="（2）修改微服务配置"></a>（2）修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">nacos:8848</span> <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure><h3 id="（3）打包"><a href="#（3）打包" class="headerlink" title="（3）打包"></a>（3）打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 服务打包的最终名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打包后：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118940021-9ed645b0-b495-4e6e-886f-27399640231e.png" alt="img"></p><h3 id="（4）拷贝jar包到部署目录"><a href="#（4）拷贝jar包到部署目录" class="headerlink" title="（4）拷贝jar包到部署目录"></a>（4）拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118949777-b9c48c30-a463-4c95-8198-87c63ca29615.png" alt="img"></p><p>order-service：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118977341-8d119a9e-9e70-402c-aaa7-4a51a3c7aac8.png" alt="img"></p><p>gateway：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648118989467-2897beb3-0ecf-43a6-9fd1-0e0b67a1ff5f.png" alt="img"></p><h3 id="（5）部署"><a href="#（5）部署" class="headerlink" title="（5）部署"></a>（5）部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22712195/1648119000632-477f3a92-bb19-4f35-8dd0-8f0f3acb0879.png" alt="img"></p><p>部署：</p><p>进入cloud-demo目录，然后运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h1 id="六、Docker镜像仓库"><a href="#六、Docker镜像仓库" class="headerlink" title="六、Docker镜像仓库"></a>六、Docker镜像仓库</h1><h2 id="1-搭建私有镜像仓库"><a href="#1-搭建私有镜像仓库" class="headerlink" title="1.搭建私有镜像仓库"></a>1.搭建私有镜像仓库</h2><h3 id="Docker镜像仓库安装"><a href="#Docker镜像仓库安装" class="headerlink" title="Docker镜像仓库安装"></a>Docker镜像仓库安装</h3><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h4 id="（1）简化版镜像仓库"><a href="#（1）简化版镜像仓库" class="headerlink" title="（1）简化版镜像仓库"></a>（1）简化版镜像仓库</h4><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h4 id="（2）带有图形化界面版本"><a href="#（2）带有图形化界面版本" class="headerlink" title="（2）带有图形化界面版本"></a>（2）带有图形化界面版本</h4><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=传智教育私有仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></table></figure><h4 id="（3）配置Docker信任地址"><a href="#（3）配置Docker信任地址" class="headerlink" title="（3）配置Docker信任地址"></a>（3）配置Docker信任地址</h4><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加内容：</span></span><br><span class="line">&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="2-推送、拉取镜像"><a href="#2-推送、拉取镜像" class="headerlink" title="2.推送、拉取镜像"></a>2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0</span><br></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push 192.168.150.101:8080/nginx:1.0</span><br></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull 192.168.150.101:8080/nginx:1.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架</title>
      <link href="/2021/12/28/%E9%9B%86%E5%90%88/"/>
      <url>/2021/12/28/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>日期：2021/12/10</p><p>内容出处：黑马：<a href="https://www.bilibili.com/video/BV1WZ4y1P7Bp?p=1">https://www.bilibili.com/video/BV1WZ4y1P7Bp?p=1</a></p><p>所学内容：Spring基本开发步骤，Spring配置文件，Spring的相关API</p><p>遇到的问题：</p><p>总结：</p><p>今天学习了Spring，了解了Spring的概念，快速地入门了Spring，知道了Spring程序开发的步骤（一般分为五步），学习Spring配置文件（这部分很重要，需要知道bean实例化的三种方式），了解了Bean的依赖注入的概念，后面在学习依赖注入这块，我学习Bean的依赖注入方式（构造方法和set方法）和依赖注入的数据类型（普通，引用，集合），这两块内容差不多掌握了。</p><p>摘要：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1639980741481-bede9b9f-e88c-4f69-9401-4270fbb21800.png" alt="img"></p><h1 id="一、Spring概述"><a href="#一、Spring概述" class="headerlink" title="一、Spring概述"></a>一、Spring概述</h1><p> \1. Spring是什么  </p><p>Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层 SpringMVC 和持久层 Spring JDBCTemplate 以及业务层事务管理等众多的企业级应用技术 ，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。  </p><p>\2. Spring的体系结构  </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1639357833184-d1454981-dec8-4eb5-afcf-a351dca40028.png" alt="img"></p><h1 id="二、Spring快速入门"><a href="#二、Spring快速入门" class="headerlink" title="二、Spring快速入门"></a>二、Spring快速入门</h1><h2 id="Spring程序开发步骤"><a href="#Spring程序开发步骤" class="headerlink" title="Spring程序开发步骤"></a>Spring程序开发步骤</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1639358198760-304e2fd3-a9ef-4d93-86c2-667c26b7070c.png" alt="img"> </p><p>① 导入 Spring 开发的基本包坐标</p><p>② 编写 Dao 接口和实现类</p><p>③ 创建 Spring 核心配置文件</p><p>④ 在 Spring 配置文件中配置 UserDaoImpl</p><p>⑤ 使用 Spring 的 API 获得 Bean 实例</p><h3 id="①-导入-Spring-开发的基本包坐标"><a href="#①-导入-Spring-开发的基本包坐标" class="headerlink" title="① 导入 Spring 开发的基本包坐标"></a>① 导入 Spring 开发的基本包坐标</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="②-编写-Dao-接口和实现类"><a href="#②-编写-Dao-接口和实现类" class="headerlink" title="② 编写 Dao 接口和实现类"></a>② 编写 Dao 接口和实现类</h3><p>1.Dao接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ytb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-10-8:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ytb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-10-8:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③-创建-Spring-核心配置文件"><a href="#③-创建-Spring-核心配置文件" class="headerlink" title="③ 创建 Spring 核心配置文件"></a>③ 创建 Spring 核心配置文件</h3><p> 在类路径下（resources）创建applicationContext.xml配置文件  </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1639358669951-4046f755-19bb-4809-8099-6705ea6f7283.png" alt="img"></p><p>applicationContext.xml文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="④-在-Spring-配置文件中配置-UserDaoImpl"><a href="#④-在-Spring-配置文件中配置-UserDaoImpl" class="headerlink" title="④ 在 Spring 配置文件中配置 UserDaoImpl"></a>④ 在 Spring 配置文件中配置 UserDaoImpl</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">bean：将一个类的对象创建过程交给spring容器</span></span><br><span class="line"><span class="comment">id：唯一标识符</span></span><br><span class="line"><span class="comment">class:指定类的具体路径（全类名）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="⑤-使用-Spring-的-API-获得-Bean-实例"><a href="#⑤-使用-Spring-的-API-获得-Bean-实例" class="headerlink" title="⑤ 使用 Spring 的 API 获得 Bean 实例"></a>⑤ 使用 Spring 的 API 获得 Bean 实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package com.itheima.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author <span class="variable">ytb</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create </span>2021-12-10-8:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserDaoDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">      <span class="comment">//1.启动框架（app代表spring容器）</span></span><br><span class="line">        ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取spring容器中创建的对象（通过id值获取）</span></span><br><span class="line">      UserDao userDao = (UserDao) app.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">      <span class="comment">//3.掉用方法</span></span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、-Spring配置文件"><a href="#三、-Spring配置文件" class="headerlink" title="三、 Spring配置文件"></a>三、 Spring配置文件</h1><h2 id="1-Bean标签基本配置"><a href="#1-Bean标签基本配置" class="headerlink" title="1.Bean标签基本配置"></a>1.Bean标签基本配置</h2><p> 用于配置对象交由Spring 来创建。 </p><p>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。  </p><p>基本属性：</p><p>  id： Bean实例在Spring容器中的唯一标识 </p><p>class： Bean的全限定名称  </p><h2 id="2-Bean标签范围配置"><a href="#2-Bean标签范围配置" class="headerlink" title="2.  Bean标签范围配置"></a>2.  Bean标签范围配置</h2><p> scope：指对象的作用范围 </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1639623134584-22c899b3-269f-453e-9142-1d44653f212b.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="3-Bean生命周期配置"><a href="#3-Bean生命周期配置" class="headerlink" title="3. Bean生命周期配置"></a>3. Bean生命周期配置</h2><p>1）当scope的取值为singleton时</p><p>Bean的实例化个数：1个</p><p>Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例</p><p>Bean的生命周期：</p><ol><li><ol><li><ol><li><ol><li> 对象创建：当应用加载，创建容器时，对象就被创建了</li><li> 对象运行：只要容器在，对象一直活着</li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li> 对象销毁：当应用卸载，销毁容器时，对象就被销毁了</li></ol></li></ol></li></ol></li></ol><p>2）当scope的取值为prototype时</p><p>Bean的实例化个数：多个</p><p>Bean的实例化时机：当调用getBean()方法时实例化Bean</p><p> Bean的生命周期：  </p><ol><li><ol><li><ol><li><ol><li> 对象创建：当使用对象时，创建新的对象实例</li><li>对象运行：只要对象在使用中，就一直活着</li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li>对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了</li></ol></li></ol></li></ol></li></ol><p>注：</p><p> init-method：指定类中的初始化方法名称 </p><p>destroy-method：指定类中销毁方法名称  </p><p>创建Person类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;人出生了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//初始化方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;人。。。初始化方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;人吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//销毁方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;人。。。销毁方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PersonTest类</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">      <span class="comment">//1.启动框架（app代表spring容器）</span></span><br><span class="line">        ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取spring容器中创建的对象（通过id值获取）</span></span><br><span class="line">      Person person = (Person) app.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">      <span class="comment">//3.目标方法</span></span><br><span class="line">        person.eat();</span><br><span class="line">      <span class="comment">//4.关闭app容器，并且销毁容器中的所有对象</span></span><br><span class="line">      ((ClassPathXmlApplicationContext)app).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applicationContext.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定init-method中的方法名--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.Person&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;detroy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">人出生了</span><br><span class="line">人。。。初始化方法</span><br><span class="line">人吃饭</span><br><span class="line">人。。。销毁方法</span><br></pre></td></tr></table></figure><h2 id="补：懒加载和非懒加载"><a href="#补：懒加载和非懒加载" class="headerlink" title="补：懒加载和非懒加载"></a>补：懒加载和非懒加载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1.启动框架（app代表spring容器）</span></span><br><span class="line">        ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">      <span class="comment">//2.获取spring容器中创建的对象（通过id只获取）</span></span><br><span class="line">      Person person = (Person) app.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">      <span class="comment">//3.目标方法</span></span><br><span class="line">        person.eat();</span><br><span class="line">      <span class="comment">//4.关闭app容器，并且销毁容器中的所有对象</span></span><br><span class="line">      <span class="comment">//((ClassPathXmlApplicationContext)app).close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applicationContext.xml文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--</span></span></span><br><span class="line"><span class="comment"><span class="xml">          &lt;import resource=&quot;&quot;/&gt;将部分配置拆解到其他配置文件中</span></span></span><br><span class="line"><span class="comment"><span class="xml">      --&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;com/itheima/p1/person.xml&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>person.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">          lazy- init:告诉spring容器是否以懒加越的方式创建对象</span></span><br><span class="line"><span class="comment">          取值有:true. false. default</span></span><br><span class="line"><span class="comment">          true/default:以懒加载的方式创建对象。当真正使用对象的时候才创建对象</span></span><br><span class="line"><span class="comment">          false:非懒加裁，容器已启动立马创建对象</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.Person&quot;</span> <span class="attr">lazy-</span> <span class="attr">init</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：</p><p>当lazy- init配置为true或者default时，为懒加载，运行结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">人出生了</span><br><span class="line">人吃饭</span><br></pre></td></tr></table></figure><p>注：</p><p>当lazy- init配置为false时，为非懒加载，运行结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">人出生了</span><br><span class="line">----------------------</span><br><span class="line">人吃饭</span><br></pre></td></tr></table></figure><p>懒加载与非懒加载的区别</p><p>懒加载：对象使用的时候才去创建。节省资源，但是不利于提前发现错误</p><p>非懒加载：容器启动时立马创建。消耗资源,有利于提前发现错误</p><h2 id="4-Bean实例化三种方式"><a href="#4-Bean实例化三种方式" class="headerlink" title="4. Bean实例化三种方式"></a>4. Bean实例化三种方式</h2><p>(1) 使用无参构造方法实例化  </p><p> 使用无参构造方法实例化 它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p> (2） 工厂静态方法实例化 </p><p>工厂的静态方法返回Bean实例  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package com.itheima.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.impl.UserDaoImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author <span class="variable">ytb</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create </span>2021-12-10-13:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> UserDao <span class="function"><span class="title">getUserDao</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1639374605883-e7997f88-ca8b-4c6b-bd5e-162055ed39e6.png" alt="img"></p><p>applicationContext.xml文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.factory.StaticFactory&quot;</span></span><br><span class="line">       factory-method=<span class="string">&quot;getUserDao&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p> (3)工厂实例方法实例化 </p><p>工厂的非静态方法返回Bean实例 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package com.itheima.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.impl.UserDaoImpl;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123;</span><br><span class="line">    public UserDao <span class="function"><span class="title">getUserDao</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> applicationContext.xml文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;factoryBean&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.factory.StaticFactory&quot;</span>/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="5-Bean的依赖注入入门"><a href="#5-Bean的依赖注入入门" class="headerlink" title="5. Bean的依赖注入入门"></a>5. Bean的依赖注入入门</h2><h3 id="①-创建-UserServiceImpl类实现UserService接口，UserServiceImpl-内部在调用-UserDao的save-方法"><a href="#①-创建-UserServiceImpl类实现UserService接口，UserServiceImpl-内部在调用-UserDao的save-方法" class="headerlink" title="① 创建 UserServiceImpl类实现UserService接口，UserServiceImpl 内部在调用 UserDao的save() 方法"></a>① 创建 UserServiceImpl类实现UserService接口，UserServiceImpl 内部在调用 UserDao的save() 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ytb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-10-18:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        UserDao userDao = (UserDao) app.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-将-UserServiceImpl-的创建权交给-Spring"><a href="#②-将-UserServiceImpl-的创建权交给-Spring" class="headerlink" title="② 将 UserServiceImpl 的创建权交给 Spring"></a>② 将 UserServiceImpl 的创建权交给 Spring</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="③-从-Spring-容器中获得-UserService-进行操作"><a href="#③-从-Spring-容器中获得-UserService-进行操作" class="headerlink" title="③ 从 Spring 容器中获得 UserService 进行操作"></a>③ 从 Spring 容器中获得 UserService 进行操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = newClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.save();</span><br></pre></td></tr></table></figure><h2 id="6-Bean的依赖注入概念"><a href="#6-Bean的依赖注入概念" class="headerlink" title="6. Bean的依赖注入概念"></a>6. Bean的依赖注入概念</h2><p>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。 IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 </p><p>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。   </p><p>坐等框架把持久层对象传入业务层，而不用我们自己去获取。  </p><h2 id="7-Bean的依赖注入方式（两种方式）"><a href="#7-Bean的依赖注入方式（两种方式）" class="headerlink" title="7.Bean的依赖注入方式（两种方式）"></a>7.Bean的依赖注入方式（两种方式）</h2><h3 id="（1）set方法注入"><a href="#（1）set方法注入" class="headerlink" title="（1）set方法注入"></a>（1）set方法注入</h3><p> 在UserServiceImpl中添加setUserDao方法  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 配置Spring容器调用set方法进行注入  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">给自定义属性赋值用ref</span></span><br><span class="line"><span class="comment">其中name的值为set方法名后面的名字，然后在将其首字母小写</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>P命名空间注入（ set方法注入的简便形式,只改变配置文件）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.引入P命名空间--&gt;</span></span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"><span class="comment">&lt;!--2.修改注入方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span> <span class="attr">p:userDaoref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">ApplicationContext applicationContext = newClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）构造方法注入"><a href="#（2）构造方法注入" class="headerlink" title="（2）构造方法注入"></a>（2）构造方法注入</h3><p>创建有参构造</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao=userDao;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">            UserDao userDao = (UserDao) applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">            userDao.save();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置Spring容器调用有参构造时进行注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">第一个userDao为有参构造函数的形参名，</span></span><br><span class="line"><span class="comment">第二个userDao为引用Spirng容器当中bean的id</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8-Bean的依赖注入的数据类型"><a href="#8-Bean的依赖注入的数据类型" class="headerlink" title="8. Bean的依赖注入的数据类型"></a>8. Bean的依赖注入的数据类型</h2><p>注入数据的三种数据类型 </p><ul><li><p> 普通数据类型 </p></li><li><p> 引用数据类型 </p></li><li><p> 集合数据类型</p></li></ul><p>（1） 普通数据类型的注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompany</span><span class="params">(String company)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.company = company;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(company+<span class="string">&quot;===&quot;</span>+age);</span><br><span class="line">    System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;company&quot;</span> <span class="attr">value</span>=<span class="string">&quot;传智播客&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）集合数据类型（List<String>）的注入（list和set使用一样）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; strList;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrList</span><span class="params">(List&lt;String&gt; strList)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.strList = strList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(strList);</span><br><span class="line">                System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;strList&quot;</span>&gt;</span><br><span class="line">                &lt;list&gt;</span><br><span class="line">                        &lt;value&gt;aaa&lt;/value&gt;</span><br><span class="line">                        &lt;value&gt;bbb&lt;/value&gt;</span><br><span class="line">                        &lt;value&gt;ccc&lt;/value&gt;</span><br><span class="line">                &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>（3）集合数据类型（List<User>）的注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserList</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userList = userList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">    System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userList&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--使用ref标签来掉用自定义类型--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）集合数据类型（ Map&lt;String,User&gt; ）的注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;String,User&gt; userMap;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserMap</span><span class="params">(Map&lt;String, User&gt; userMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMap = userMap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(userMap);</span><br><span class="line">                System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span><span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（5）集合数据类型（Properties）的注入（只能存放String类型）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Properties properties;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(properties);</span><br><span class="line">            System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-引入其他配置文件（分模块开发）"><a href="#9-引入其他配置文件（分模块开发）" class="headerlink" title="9.引入其他配置文件（分模块开发）"></a>9.引入其他配置文件（分模块开发）</h2><p>将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载</p><import resource="applicationContext-xxx.xml"/><h1 id="四、Spring相关API"><a href="#四、Spring相关API" class="headerlink" title="四、Spring相关API"></a>四、Spring相关API</h1><p>1.ApplicationContext的继承体系</p><p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1639968670463-a39219f3-e7ce-4ecc-8ef5-633f10639ee8.png" alt="img"></p><p>2.ApplicationContext的实现类</p><p>（1）ClassPathXmlApplicationContext 它是从类的根路径下加载配置文件 推荐使用这种 </p><p>（2）FileSystemXmlApplicationContext 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 </p><p>（3）AnnotationConfigApplicationContext 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p><p>3.getBean()方法使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    assertBeanFactoryActive();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    assertBeanFactoryActive();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java使用Class类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ytb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-10-8:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1.启动框架（app代表spring容器）</span></span><br><span class="line">        ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取spring容器中创建的对象（通过id值获取）</span></span><br><span class="line">      <span class="comment">//UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.获取spring容器中创建的对象（通过class类型获取）</span></span><br><span class="line">        UserDao userDao = app.getBean(<span class="string">&quot;UserDao.class&quot;</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//3.掉用方法</span></span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">bean：将一个类的对象创建过程交给spring容器</span></span><br><span class="line"><span class="comment">id：唯一标识符</span></span><br><span class="line"><span class="comment">class:指定类的具体路径（全类名）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--使用class类型是只能存在一个bean</span></span><br><span class="line"><span class="comment">&lt;bean id=&quot;userDao1&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：</p><p>其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。 当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时， 则此方法会报错。</p><p>注：Spring的重点API</p><p>ApplicationContext app = new ClasspathXmlApplicationContext(“xml文件”)</p><p>app.getBean(“id”)</p><p>app.getBean(Class)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qq</title>
      <link href="/2021/12/28/qq/"/>
      <url>/2021/12/28/qq/</url>
      
        <content type="html"><![CDATA[<h2 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件建立日期</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2021/12/28/%E2%80%9Cgit%E2%80%9D/"/>
      <url>/2021/12/28/%E2%80%9Cgit%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>日期：2021/12/8~9</p><p>内容出处：</p><p>黑马程序员Git全套教程，完整的git项目管理工具教程，一套精通git：<a href="https://www.bilibili.com/video/BV1MU4y1Y7h5?spm_id_from=333.788.b_636f6d6d656e74.11">https://www.bilibili.com/video/BV1MU4y1Y7h5?spm_id_from=333.788.b_636f6d6d656e74.11</a></p><p>所学内容：git的概念和工作流程，git的安装与环境配置，git分支和远程仓库，在idea中使用git</p><p>遇到的问题：</p><p>总结：</p><p>12月8日学习了git的常用指令，获取本地仓库，基础操作指令，分支操作（其中需要了解开发中分支使用原则与流程），了解了git 的工作流程，完成了git的环境配置与安装和远程仓库操作，其中远程仓库这块比较重要需要掌握它的操作流程。</p><p>12月9日学习了idea中使用ait，完成了在idea中操作git，试着在idea中创建项目远程仓库，做起来不难，跟着步骤一步步来就好。学完git指令，又安装了Hexo，然后试着自己搭建了博客，因为我没买服务器，所以就使用github提供的托管服务，然后使用本地hexo的默认模板（能访问到默认的网页了，后面就是自己添加模板主题），但是主题还没安装。</p><h1 id="1-Git概念"><a href="#1-Git概念" class="headerlink" title="1.Git概念"></a>1.Git概念</h1><p>一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理</p><h1 id="2-Git工作流程图"><a href="#2-Git工作流程图" class="headerlink" title="2.Git工作流程图"></a>2.Git工作流程图</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640085754202-da29785b-0898-4f54-bfb9-689d80777819.png" alt="img"></p><p>命令如下：</p><p>\1. clone（克隆）: 从远程仓库中克隆代码到本地仓库</p><p>\2. checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订</p><p>\3. add（添加）: 在提交前先将代码提交到暂存区</p><p>\4. commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本</p><p>\5. fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</p><p>\6. pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于</p><p>fetch+merge</p><p>\7. push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</p><h1 id="3-git安装"><a href="#3-git安装" class="headerlink" title="3.git安装"></a>3.git安装</h1><p>git下载教程：<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></p><h1 id="4-Git环境配置"><a href="#4-Git环境配置" class="headerlink" title="4.Git环境配置"></a>4.Git环境配置</h1><h2 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1.基本配置"></a>1.基本配置</h2><p>\1. 打开Git Bash</p><p>\2. 设置用户信息</p><p>git conﬁg –global user.name “itcast”</p><p>git conﬁg –global user.email “<a href="mailto:&#104;&#x65;&#108;&#x6c;&#x6f;&#64;&#105;&#116;&#x63;&#97;&#x73;&#116;&#x2e;&#99;&#110;">&#104;&#x65;&#108;&#x6c;&#x6f;&#64;&#105;&#116;&#x63;&#97;&#x73;&#116;&#x2e;&#99;&#110;</a>”</p><p>查看配置信息</p><p>git conﬁg –global user.name</p><p>git conﬁg –global user.email</p><h2 id="2-解决GitBash乱码问题"><a href="#2-解决GitBash乱码问题" class="headerlink" title="2.解决GitBash乱码问题"></a>2.解决GitBash乱码问题</h2><p>\1. 打开GitBash执行下面命令</p><p>git config –global core.quotepath false</p><p>\2. ${git_home}/etc/bash.bashrc 文件最后加入下面两行</p><p>export LANG=”zh_CN.UTF-8”</p><p>export LC_ALL=”zh_CN.UTF-8”</p><h2 id="3-获取本地仓库"><a href="#3-获取本地仓库" class="headerlink" title="3.获取本地仓库"></a>3.获取本地仓库</h2><p>要使用Git对我们的代码进行版本控制，首先需要获得本地仓库</p><p>1）在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库</p><p>2）进入这个目录中，点击右键打开Git bash窗口</p><p>3）执行命令git init</p><p>4）如果创建成功后可在文件夹下看到隐藏的.git目录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640308339495-c7d018aa-b08d-47eb-9dcc-08d3bcf4a82a.png" alt="img"></p><h2 id="4-基础操作指令"><a href="#4-基础操作指令" class="headerlink" title="4.基础操作指令"></a>4.基础操作指令</h2><p> \1. git add (工作区 –&gt; 暂存区) </p><p>\2. git commit (暂存区 –&gt; 本地仓库)  </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640087677476-4b550db9-f9c0-494b-a89b-e992073db66b.png" alt="img"></p><p>1.查看修改的状态（status）</p><p>作用：查看的修改的状态（暂存区、工作区）</p><p>命令形式：git status</p><p>2.添加工作区到暂存区(add)</p><p>作用：添加工作区一个或多个文件的修改到暂存区</p><p>命令形式：git add 单个文件名|通配符</p><p>将所有修改加入暂存区：git add .</p><p>3.提交暂存区到本地仓库(commit)</p><p>作用：提交暂存区内容到本地仓库的当前分支</p><p>命令形式：git commit -m ‘注释内容’</p><p>4.查看提交日志(log)</p><p>在3.1.3中配置的别名 - 就包含了这些参数，所以后续可以直接使用指令 -</p><p>作用:查看提交记录</p><p>命令形式：git log [option]</p><p>options</p><p>–all 显示所有分支</p><p>–pretty=oneline 将提交信息显示为一行</p><p>–abbrev-commit 使得输出的commitId更简短</p><p>5.版本回退</p><p>作用：版本切换</p><p>命令形式：git reset –hard commitID</p><p>commitID 可以使用 git-log 或 git log 指令查看</p><p>如何查看已经删除的记录？</p><p>git reﬂog</p><p>这个指令可以看到已经删除的提交记录</p><p>6.添加文件至忽略列表</p><p>一些无需纳入Git 的管理的文件，自动生成的文件。如日志文件，或者编译过程中创建的临时文件等。我们可以在工作目录 中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式。  </p><p>示例：</p><p>在工作目录中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># no .a files</span><br><span class="line">*</span><br><span class="line">.</span><br><span class="line">a</span><br><span class="line"># but do track lib.a, even though you&#x27;re ignoring .a files above</span><br><span class="line">!lib.a</span><br><span class="line"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># ignore all files in the build/ directory</span><br><span class="line">build/</span><br><span class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># ignore all .pdf files in the doc/ directory</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h1 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h1><p>1、查看本地分支</p><p>命令：git branch</p><p>2、创建本地分支</p><p>命令：git branch 分支名</p><p>3、切换分支(checkout)</p><p>命令：git checkout 分支名</p><p>我们还可以直接切换到一个不存在的分支（创建并切换）</p><p>命令：git checkout -b 分支名</p><p>4、合并分支(merge)</p><p>一个分支上的提交可以合并到另一个分支</p><p>命令：git merge 分支名称</p><p>5、删除分支</p><p><strong>不能删除当前分支，只能删除其他分支</strong></p><p>git branch -d b1 删除分支时，需要做各种检查</p><p>git branch -D b1 不做任何检查，强制删除</p><p>6、解决冲突</p><p>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解</p><p>决冲突，解决冲突步骤如下：</p><p>\1. 处理文件中冲突的地方</p><p>\2. 将解决完冲突的文件加入暂存区(add)</p><p>\3. 提交到仓库(commit)</p><p> 在开发中，一般有如下分支使用原则与流程： </p><p>master（生产）</p><p>分支线上分支，主分支，中小规模项目作为线上运行的应用对应的分支； </p><p>develop（开发）</p><p>分支是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线 要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线。</p><p> feature/xxxx分支 </p><p>从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完 成后合并到develop分支。</p><p> hotfix/xxxx分支 </p><p>从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支。</p><p>还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等 等。  </p><h1 id="6、Git远程仓库"><a href="#6、Git远程仓库" class="headerlink" title="6、Git远程仓库"></a>6、Git远程仓库</h1><h2 id="1-常用的托管服务-远程仓库"><a href="#1-常用的托管服务-远程仓库" class="headerlink" title="1.常用的托管服务[远程仓库]"></a>1.常用的托管服务[远程仓库]</h2><p>gitHub（ 地址：<a href="https://github.com/">https://github.com/</a> ）是一个面向开源及私有软件项目的托管平台，因为只支持</p><p>Git 作为唯一的版本库格式进行托管，故名gitHub</p><p>码云（地址： <a href="https://gitee.com/">https://gitee.com/</a> ）是国内的一个代码托管平台，由于服务器在国内，所以相比于</p><p>GitHub，码云速度会更快</p><p>GitLab （地址： <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用Git作</p><p>为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。</p><h2 id="2-使用码云创建远程仓库"><a href="#2-使用码云创建远程仓库" class="headerlink" title="2.使用码云创建远程仓库"></a>2.使用码云创建远程仓库</h2><p>1.注册码云 </p><p> 前往网址<a href="https://gitee.com/signup">https://gitee.com/signup</a> 注册</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640314188251-7985dc38-c983-4056-971d-9aab17f88267.png" alt="img"></p><p>\2. 创建远程仓库  </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640315005135-360f9ffe-fb41-4b28-96e7-0fc3e6c6a7c5.png" alt="img"></p><p> 仓库创建完成后可以看到仓库地址，如下图所示:  </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640315886384-8a8df281-83a1-45bb-bd9f-f632e42d42bc.png" alt="img"></p><p>\3. 配置SSH公钥  </p><p> 生成SSH公钥 </p><ul><li><ul><li>ssh-keygen -t rsa </li><li>不断回车 </li></ul></li><li><ul><li><ul><li>如果公钥已经存在，则自动覆盖 </li></ul></li></ul></li></ul><p>Gitee设置账户共公钥 </p><ul><li><ul><li>获取公钥 </li></ul></li><li><ul><li><ul><li>cat ~/.ssh/id_rsa.pub  </li></ul></li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640316066614-c2fcbf3d-1b39-4644-9f8e-3dd28868363f.png" alt="img"></p><p>将所获取的公钥复制粘贴</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640316321785-1ecd46d0-dfc1-4bdb-820c-81870272bf82.png" alt="img"></p><p>输入如下命令验证，看是否成功配置ssh，出现successfully说明成功</p><p> ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x65;&#x65;&#46;&#99;&#111;&#109;">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x65;&#x65;&#46;&#99;&#111;&#109;</a>  </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640316408839-4f8436de-b1ed-4a06-9068-3b5aaeb19ae9.png" alt="img"></p><h2 id="3-操作远程仓库"><a href="#3-操作远程仓库" class="headerlink" title="3.操作远程仓库"></a>3.操作远程仓库</h2><p>\1. 添加远程仓库  </p><p> <strong>此操作是先初始化本地库，然后与已创建的远程库进行对接。</strong></p><p> 命令： git remote add &lt;远端名称&gt; &lt;仓库路径&gt; </p><ul><li><p>远端名称，默认是origin，取决于远端服务器设置 </p></li><li><p>仓库路径，从远端服务器获取此URL </p></li><li><p>例如: git remote add origin <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>:xiaobin133/git_test.git </p></li></ul><p>（1）初始化本地库</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640325394973-435084a4-0e70-4093-b957-00e667002416.png" alt="img"></p><p>（2）与已创建的远程库进行对接</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640325462257-3f12bd87-aecf-4acf-b646-c2fc23fa6bd3.png" alt="img"></p><p>\2. 查看远程仓库  </p><p> 命令：git remote  </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640325512293-fe7817df-1d15-4866-b835-8cee3ab5e78c.png" alt="img"></p><p>\3. 推送到远程仓库  </p><p> 命令：git push [-f] [–set-upstream] [远端名称 [本地分支名][:远端分支名] ] </p><ul><li><ul><li>如果远程分支名和本地分支名称相同，则可以只写本地分支 </li></ul></li><li><ul><li><ul><li>git push origin master </li></ul></li></ul></li><li><ul><li>-f 表示强制覆盖 </li><li>–set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。 </li></ul></li><li><ul><li><ul><li>git push –set-upstream origin master </li></ul></li></ul></li><li><ul><li>如果当前分支已经和远端分支关联，则可以省略分支名和远端名。 </li></ul></li><li><ul><li><ul><li>git push 将master分支推送到已关联的远端分支。  </li></ul></li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640328404515-7ff559ef-5cd7-4015-8cd7-2f26af5ddc81.png" alt="img"></p><p>简易的命令行入门教程:</p><p>Git 全局设置:</p><p>git config –global user.name “小斌”</p><p>git config –global user.email “<a href="mailto:&#50;&#x33;&#49;&#x30;&#52;&#x39;&#51;&#x32;&#48;&#49;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#50;&#x33;&#49;&#x30;&#52;&#x39;&#51;&#x32;&#48;&#49;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;</a>“</p><p>创建 git 仓库:</p><p>mkdir test</p><p>cd test</p><p>git init</p><p>touch README.md</p><p>git add README.md</p><p>git commit -m “first commit”</p><p>git remote add origin <a href="mailto:&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#x65;&#101;&#46;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#x65;&#101;&#46;&#99;&#x6f;&#x6d;</a>:xiaobin133/test.git</p><p>git push -u origin master</p><p>已有仓库?</p><p>cd existing_git_repo</p><p>git remote add origin <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#105;&#116;&#101;&#x65;&#x2e;&#99;&#111;&#x6d;">&#103;&#x69;&#116;&#64;&#103;&#105;&#116;&#101;&#x65;&#x2e;&#99;&#111;&#x6d;</a>:xiaobin133/test.git</p><p>git push -u origin master</p><p>\4. 查询远程仓库  </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640328549863-90a708f2-0e4b-4943-9952-a82cd887ef9d.png" alt="img"></p><p>\5. 本地分支与远程分支的关联关系  </p><p> 查看关联关系我们可以使用 git branch -vv 命令  </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640328674980-d4413b48-920b-45c6-8682-e11d295159e3.png" alt="img"></p><p>\6. 从远程仓库克隆 </p><p> 如果已经有一个远端仓库，我们可以直接clone到本地。</p><p> 命令: git clone &lt;仓库路径&gt; [本地目录] </p><ul><li>本地目录可以省略，会自动生成一个目录  </li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640330146235-166a6ee6-2d7c-4660-b305-550fb59b4f25.png" alt="img"></p><p>\7. 从远程仓库中抓取和拉取   </p><p>远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本<br>地，再进行操作。</p><ul><li><p>抓取 命令：git fetch [remote name] [branch name]</p></li><li><ul><li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并<br>黑马程序员 北京昌平校区</li><li>如果不指定远端名称和分支名，则抓取所有分支。</li></ul></li><li><p>拉取 命令：git pull [remote name] [branch name]</p></li><li><ul><li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul></li></ul><ol><li>在test这个本地仓库进行一次提交并推送到远程仓库</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640337190626-650abeec-03ca-49f3-b978-02ed4d7d4bc0.png" alt="img"></p><ol><li> 在另一个仓库将远程提交的代码拉取到本地仓库  </li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640337359333-58ff3d42-39dc-489a-9726-5bb424888f0c.png" alt="img"></p><p>3.可以在文件中看到远程仓库中的资料拉取了本地仓库</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640337596733-d9b866da-73ba-4cc0-8ada-1014a424ce33.png" alt="img"></p><h1 id="7-在Idea中使用Git"><a href="#7-在Idea中使用Git" class="headerlink" title="7.在Idea中使用Git"></a>7.在Idea中使用Git</h1><p> 场景：本地已经有一个项目，但是并不是git项目，我们需要将这个放到码云的仓库里，和其他开发人员 继续一起协作开发  </p><p> 1.创建项目远程仓库 </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640332295693-814161a0-52a0-406b-b205-b9e4dba39c2e.png" alt="img"> </p><p> 2.上传到远程仓库</p><p>选择File→Settings打开设置窗口，找到Version Control下的git选项，配置git的路径  </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640331108229-6470fc20-61df-439f-bbc7-cefc8af41d18.png" alt="img"></p><p>创建本地仓库，VCS–&gt;VCS Operations–&gt;Create Git Repository</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640334597111-8cd138dd-8ca7-4e79-91bd-6c6c699a16e9.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640334735967-e422df75-1a8d-41f9-a73a-0dbabe7e445f.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640334793453-03a327af-89cd-4240-b986-15d640baac33.png" alt="img"></p><p>在弹框中选中项目所在的位置，点击OK，此时项目文件全部变成红色（若选中其他位置，则git–&gt;add不可点选，不知为何）</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640334634417-08191a06-fa28-4db3-85fa-b7846869cece.png" alt="img"></p><p>上传项目到本地仓库，项目右键选择Git–&gt;add，此时项目文件变成绿色，此时文件只是处于暂存区，并没有真正进入到版本库中</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640334409497-5bc2e203-c1cf-467f-a985-081fc5e2d563.png" alt="img"> </p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640334961098-194d813f-a884-438d-8854-aa7bef9fa85f.png" alt="img"></p><p> 项目右键Git–&gt; Commit Directory，在弹窗中输入Commit Message，点击commit，此时项目文件从暂存区真正进入版本库中，项目文件变成白色</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640335038654-c0982759-01df-4b4c-8368-d04bf2b3be90.png" alt="img"></p><p>这里选择commit and push</p><p>然后配置push的信息  push即可</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640335377586-56e5526c-e196-4f5a-abb1-c7ea19683f32.png" alt="img"></p><p>项目变成白色，及成功推送到远程仓库</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640335456061-3d09aae4-da5d-417c-a050-973e7c90ec13.png" alt="img"></p><p>去自己所建的仓库查看，可发现上传成功</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/22712195/1640335850502-c77436c9-825e-4c47-b9f4-dc3747985984.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/12/15/hello-world/"/>
      <url>/2021/12/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
